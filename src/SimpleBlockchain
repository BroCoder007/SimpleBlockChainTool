import java.util.Scanner;


 //Simple Blockchain 
 
 // LOGIC AND DESIGN
 // This program simulates a simplified blockchain using a custom-built Doubly
 // Linked List (DLL) as its core data structure. This version has been modified to
 // operate without a `latestBlock` (tail) pointer, relying solely on the `delBlock`
 // (head) pointer to manage the chain.
 //
 // The structure is divided into:
 // 1.  BlockNode: The node class for the DLL.
 // 2.  BlockchainLedger: The DLL implementation managing the chain with only a head pointer.
 // 3.  SimpleBlockchain: The main class that drives the program.
 //
 // The removal, find, sort, and now add/reverse-print operations all rely on list traversal.
 //
 // TIME COMPLEXITY
 // - Add Block ('A'): O(n). To add a new block, the list must be traversed from the
 // `delBlock` block to find the end of the chain.
 // - Delete/Find Block ('D'/'F'): O(n). To find a block by its ID, the list must be
 // traversed from the beginning.
 // - Print ('P'): O(n). Requires a full traversal of the chain.
 // - Reverse Print ('R'): O(n). Requires a traversal to find the last block, then
 // another traversal backward to print.
 // - Sort by Type ('S'): O(n). The list is traversed once to partition the blocks.
 
public class SimpleBlockchain {

    
     // Represents one block in the chain. This is our "Node".
    
     // The Doubly Linked List ADT for managing the blockchain using only a head pointer.
     
    static class BlockchainLedger {
        private BlockNode delBlock = null; // Head of the list

        
         // Adds a new block to the end of the chain. This is now an O(n) operation.
         ///
        public void addBlock(String id, String data, String type) {
            BlockNode newBlock = new BlockNode(id, data, type);
            if (delBlock == null) {
                delBlock = newBlock;
            } else {
                BlockNode last = delBlock;
                while (last.next != null) {
                    last = last.next;
                }
                last.next = newBlock;
                newBlock.prev = last;
            }
            System.out.printf("Block %s (%s - %s) added.\n", id, data, type);
        }

        
         // Finds and deletes a block by its ID. Requires O(n) traversal.
         ///
        public void deleteBlock(String id) {
            BlockNode current = delBlock;
            while (current != null && !current.blockId.equals(id)) {
                current = current.next;
            }

            if (current == null) {
                System.out.printf("Block %s not found.\n", id);
                return;
            }

            if (current.prev != null) {
                current.prev.next = current.next;
            } else {
                // We are removing the delBlock block
                delBlock = current.next;
            }

            if (current.next != null) {
                current.next.prev = current.prev;
            }
            // No tail pointer to update
            System.out.printf("Block %s removed.\n", id);
        }

        
         // Finds and prints a block by its ID. Requires O(n) traversal.
         ///
        public void findBlock(String id) {
            BlockNode current = delBlock;
            while (current != null && !current.blockId.equals(id)) {
                current = current.next;
            }

            if (current != null) {
                System.out.printf("%s %s %s\n", current.blockId, current.blockData, current.blockType);
            } else {
                System.out.printf("Block %s not found.\n", id);
            }
        }

        
         // Sorts the chain by partitioning it into two sub-lists and merging them.
         ///
        public void sortChain(String type) {
            if (delBlock == null) {
                 System.out.printf("Blockchain sorted with %s blocks first.\n", type);
                return;
            }

            BlockNode sortedHead = null, sortedTail = null;
            BlockNode otherHead = null, otherTail = null;

            BlockNode current = delBlock;
            while (current != null) {
                BlockNode nextNode = current.next;
                current.next = null; // Detach the node from the list
                current.prev = null;

                if (current.blockType.equals(type)) {
                    if (sortedHead == null) {
                        sortedHead = sortedTail = current;
                    } else {
                        sortedTail.next = current;
                        current.prev = sortedTail;
                        sortedTail = current;
                    }
                } else {
                    if (otherHead == null) {
                        otherHead = otherTail = current;
                    } else {
                        otherTail.next = current;
                        current.prev = otherTail;
                        otherTail = current;
                    }
                }
                current = nextNode;
            }

            // Re-link the two partitions
            if (sortedHead == null) {
                this.delBlock = otherHead;
            } else {
                this.delBlock = sortedHead;
                if (otherHead != null) {
                    sortedTail.next = otherHead;
                    otherHead.prev = sortedTail;
                }
            }
            System.out.printf("Blockchain sorted with %s blocks first.\n", type);
        }

        /////
         // Prints the chain from delBlock to the end.
         ///
        public void printChain() {
            if (delBlock == null) {
                System.out.println("Blockchain is empty");
                return;
            }
            BlockNode current = delBlock;
            while (current != null) {
                System.out.printf("%s %s %s\n", current.blockId, current.blockData, current.blockType);
                current = current.next;
            }
        }

        /////
         // Prints the chain in reverse. Requires finding the end first.
         ///
        public void printChainReverse() {
            if (delBlock == null) {
                System.out.println("Blockchain is empty");
                return;
            }
            // First, find the last node
            BlockNode last = delBlock;
            while (last.next != null) {
                last = last.next;
            }

            // Now, traverse backward from the last node
            BlockNode current = last;
            while (current != null) {
                System.out.printf("%s %s %s\n", current.blockId, current.blockData, current.blockType);
                current = current.prev;
            }
        }
    }

    /////
     // Main driver method for the blockchain simulation.
     ///
    public static void main(String[] args) {
        Scanner inputScanner = new Scanner(System.in);
        BlockchainLedger ledger = new BlockchainLedger();
        
        int n = Integer.parseInt(inputScanner.nextLine());

        for (int i = 0; i < n; i++) {
            String[] command = inputScanner.nextLine().split(" ");
            String operation = command[0];

            if (operation.equals("A")) {
                ledger.addBlock(command[1], command[2], command[3]);
            } else if (operation.equals("D")) {
                ledger.deleteBlock(command[1]);
            } else if (operation.equals("P")) {
                ledger.printChain();
            } else if (operation.equals("R")) {
                ledger.printChainReverse();
            } else if (operation.equals("S")) {
                ledger.sortChainByType(command[1]);
            } else if (operation.equals("F")) {
                ledger.findBlock(command[1]);
            } else {
                System.out.println("Unknown operation: " + operation);
            }
        }
        inputScanner.close();
    }
}
